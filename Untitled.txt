		
					



EXPERIMENT – 1
Objective - Write a code to implement insertion and deletion of data element in an array.

Code – 

#include <iostream>
using namespace std;
int main() 
{
    int n, b;
    cout << "Enter the size of the array : ";
    cin >> n;
    int a[100];
    cout << "Enter the elements of the array" << endl;
    for (int i = 0; i < n; i++) 
    {
        cin >> a[i];
    }
    do {
        cout << "Enter your choice" << endl << "Choose 1 for insertion" << endl
             << "Choose 2 for deletion " << endl << "Choose 3 to exit " << endl;
        cin >> b;
        switch (b) {

        case 1:
            int c;
            cout << "Enter the new number to be inserted" << endl;
            cin >> c;
            a[n] = c;
            n++;
            cout << "Array after insertion" << endl;
            for (int i = 0; i < n; i++) {
                cout << a[i] << " ";
            }
            cout << endl;
            break;

        case (2):
            cout << "Enter the number to be deleted" << endl;
            cin >> c;
            for (int i = 0; i < n; i++) {
                for (int i = 0; i < n; i++) {
                    if (c == a[i]) {
                        for (int j = i; j < n; j++) {
                            a[j] = a[j + 1];
                        }
                        n--; 
     cout << "Array after deletion" << endl;
                        for (int i = 0; i < n; i++) {
                            cout << a[i] << " ";
                        }
                        cout << endl;
                        break;
                    }
                    else if (i == n) {
                        cout << "Element not found";
                    }
                }
            }
            n--;
            break;

        case 3:
            break;

        default:
            cout << "Invalid Choice" << endl;
        }
    } while (b != 3);
    return 0;
}
 
Output –


 
EXPERIMENT – 2
OBJECTIVE - Write a program to implement STACK using linear array.

Code – 

#include <iostream>
using namespace std;

int stack[5], n = 5, top = -1;

void push(int val)
{
    if (top >= n - 1)
    {
        cout << "Stack Overflow" << endl;
    }
    else
    {
        top++;
        stack[top] = val;
    }
}
void pop()
{
    if (top <= -1)
    {
        cout << "Stack Underflow" << endl;
    }
    else
    {
        cout << "The popped element is " << stack[top] << endl;
        top--;
    }
}

void display()
{
    if (top >= 0)
    {
        cout << "Stack Elements are : " << endl;
        for (int i = top; i >= 0; i--)
        {
            cout << stack[i] << " ";
        }
        cout << endl;
  }
    else
    {
        cout << "Stack is Empty" << endl;
    }
}

int main()
{
    int ch, val;
    do
    {
        cout << "Your available choices" << endl
             << "1. Push in Stack." << endl
             << "2. Pop from Stack." << endl
             << "3. Display Stack." << endl
             << "4. Exit" << endl;

        cout << "Enter your choice : ";
        cin >> ch;
        switch (ch)
        {
        case 1:

            cout << "Enter value to be pushed : ";
            cin >> val;
            push(val);
            break;

        case 2:
            pop();
            break;
        case 3:
            display();
            break;
        case 4:
            cout << "Exit" << endl;
            break;

        default:
            cout << "Invalid Choice" << endl;
            break;
        }
    } 
    while (ch != 4);
    return 0;

Output –

 
EXPERIMENT – 3

OBJECTIVE - Write a Program for Linear Search of an element in an array.

Code – 

#include <iostream>
using namespace std;
int lsearch(int[], int, int);
int main()
{
    int ar[50], item, index, n;
    cout << "Enter the size of the Array : ";
    cin >> n;
    cout << "Enter the elements of the array : " << endl;
    for (int i = 0; i < n; i++)
    {
        cin >> ar[i];
    }
    cout << "Enter the elements to be search : ";
    cin >> item;
    index = lsearch(ar, n, item);
    if (index == -1)
    {
        cout << endl
             << "Element not found." << endl;
    }
    else
    {
        cout << "Element found at index : " << index << ", position " << index + 1;
    }
    return 0;
}
int lsearch(int ar[], int size, int it)
{
    for (int i = 0; i < size; i++)
    {
        if (ar[i] == it)
        {
            return i;
        }
    }
    return -1;
}

Output –





 
EXPERIMENT – 4

OBJECTIVE - Write a Program to Implement Binary Search on Sorted Array.

Code – 

#include <iostream>
using namespace std;
int binarySearch(int arr[], int l, int r, int x)
{
    if (r >= l)
    {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binarySearch(arr, l, mid - 1, x);
        return binarySearch(arr, mid + 1, r, x);
    }
    return -1;
}
int main()
{
    int ar[50], item, index, N, x;
    cout << "enter the size of the array:";
    cin >> N;
    cout << "enter the elements of the array:\n";
    for (int i = 0; i < N; i++)
    {
        cin >> ar[i];
    }
    cout << "enter the element to be searched for:\n";
    cin >> x;
    int result = binarySearch(ar, 0, N - 1, x);
    (result == -1)
        ? cout << "Element is not present in array"
        : cout << "Element is present at index " << result;
    return 0;
}


 
Output –




 
EXPERIMENT – 5

OBJECTIVE - Write a program to implement QUEUE using array. 

Code – 

#include <iostream>
using namespace std;
int queue[100], n = 100, front = -1, rear = -1;
void insert()
{
    int val;
    if (rear == n - 1)
    {
        cout << "Queue Overflow" << endl;
    }
    else
    {
        if (front == -1)
            front = 0;
        cout << "Insert the element in queue : " << endl;
        cin >> val;
        rear++;
        queue[rear] = val;
    }
}
void Delete()
{
    if (front == -1 || front > rear)
    {
        cout << "Queue Underflow" << endl;
        return;
    }
    else
    {
        cout << "Element deleted from queue is : " << queue[front] << endl;
        front++;
    }
}
void Display()
{
    if (front == -1)
    {
        cout << "Queue is Empty." << endl;
    }
    else
    {
        cout << "Queue elements are : ";
        for (int i = front; i <= rear; i++)
        {
            cout << queue[i] << " ";
        }
        cout << endl;
    }
}
int main()
{
    int ch;
    do
    {
        cout << "1. Insert element to queue." << endl;
        cout << "2. Delete element from Queue." << endl;
        cout << "3. Display all the elements of the queue." << endl;
        cout << "4. Exit" << endl;
        cout << "Enter your choice : " << endl;
        cin >> ch;
        switch (ch)
        {
        case 1:
            insert();
            break;
        case 2:
            Delete();
            break;
        case 3:
            Display();
            break;
        case 4:
            cout << "Exiting from the Program." << endl;
            break;
        default:
            cout << "Invalid Choice!!!!!!!!!!!!!" << endl;
        }
    } while (ch != 4);
    return 0;
}


 
Output –


 
EXPERIMENT – 6

OBJECTIVE - Write a program to implement CIRCULAR QUEUE using array.

Code – 

#include <iostream>
using namespace std;
#define max 10
int queue[10];
int rear = -1, front = 0, count = 0;
void enqueue()
{
    int data;
    if (count == max)
    {
        cout << "Queue Overflow" << endl;
    }
    else
    {
        cout << "Enter the Element : ";
        cin >> data;
        rear = (rear + 1) % max;
        queue[rear] = data;
        count = count + 1;
    }
}
void dequeue()
{
    if (count == 0)
    {
        cout << "Queue is empty." << endl;
    }
    else
    {
        cout << "Deleted element is : " << queue[front] << endl;
        front = (front + 1) % max;
        count = count - 1;
    }
}
void display()
{
    if (count == 0)
    {
        cout << "Queue is empty." << endl;
    }
    else
    {
        cout << "Elements of the Queue are : ";
        for (int i = front; i != rear; i = (i + 1) % max)
        {
            cout << queue[i] << " ";
        }
        cout << queue[rear] << endl;
    }
}
int main()
{
    int choice;
    do
    {
        cout << "Press 1. Insert an element." << endl;
        cout << "Press 2. Delete an element." << endl;
        cout << "Press 3. Dispaly the element." << endl;
        cout << "Press 4. Exit." << endl;
        cout << "Enter your choice : ";
        cin >> choice;
        switch (choice)
        {
        case 1:
            enqueue();
            break;
        case 2:
            dequeue();
            break;
        case 3:
            display();
            break;
        case 4:
            cout << "Exiting the Program.";
            exit(0);
            break;
        default:
            break;
        }
    } while (choice != 4);
    return 0;
}


Output –




 
EXPERIMENT – 7

OBJECTIVE - Write a program to implement PRIORITY QUEUE using array.

Code –
 
#include <iostream>
using namespace std;
#include <limits.h>
#define MAX 5
int idx = -1;
int pqVal[MAX];
int pqPriority[MAX];
int isEmpty()
{
    return idx == -1;
}
int isFull()
{
    return idx == MAX - 1;
}
void enqueue(int data, int priority)
{
    if (!isFull())
    {
        idx++;
        pqVal[idx] = data;
        pqPriority[idx] = priority;
    }
}
int peek()
{
    int maxPriority = INT_MIN;
    int indexPos = -1;
    for (int i = 0; i <= idx; i++)
    {
        if (maxPriority == pqPriority[i] && indexPos > -1 && pqVal[indexPos] < pqVal[i])
        {
            maxPriority = pqPriority[i];
            indexPos = i;
        }
        else if (maxPriority < pqPriority[i])
        {
            maxPriority = pqPriority[i];
            indexPos = i;
        }
    }
    return indexPos;
}
void dequeue()
{
    if (!isEmpty())
    {
        int indexPos = peek();
        for (int i = indexPos; i < idx; i++)
        {
            pqVal[i] = pqVal[i + 1];
            pqPriority[i] = pqPriority[i + 1];
        }
        idx--;
    }
}
void display()
{
    for (int i = 0; i <= idx; i++)
    {
        cout << "(" << pqVal[i] << ", " << pqPriority[i] << ")" << endl;
    }
}
int main()
{
    enqueue(5, 1);
    enqueue(10, 3);
    enqueue(15, 4);
    enqueue(20, 5);
    enqueue(500, 2);
    cout << "Before Dequeue : \n";
    display();
    dequeue();
    dequeue();
    cout << "\nAfter Dequeue : \n";
    display();
    return 0;
}

 
Output –



 
EXPERIMENT – 8
OBJECTIVE - Write a C++ program to perform insertion at beginning of linked list. 

Code –

#include <iostream>
using namespace std;
class node
{
public:
    int data;
    node *next;
    node(int val)
    {
        data = val;
        next = NULL;
    }
};
void insertAtHead(node *&head, int val)
{
    node *n = new node(val);
    n->next = head;
    head = n;
}
void display(node *head)
{
    node *temp = head;
    while (temp != NULL)
    {
        cout << temp->data << "->";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
int main()
{
    node *head = NULL;
    int data, n, x;
    do
    {
        cout << "Enter 1 to Insert at Beginning" << endl;
        cout << "Enter 2 to Display linked List" << endl;
        cout << "Enter 3 to EXIT." << endl;
        cin >> x;
        switch (x)
        {
        case 1:
            cout << "Enter No of values to be Inserted at Beginning" << endl;
            cin >> n;
            cout << "Enter the values to be inserted at the beginning" << endl;
            for (int i = 0; i < n; i++)
            {
                cin >> data;
                insertAtHead(head, data);
            }
            break;
        case 2:
            cout << "The Linked List is :- " << endl;
            display(head);
            break;
        case 3:
            break;
        default:
            cout << "Invalid Choice" << endl;
        }
    } while (x != 3);
    return 0;
}
 
Output –

 

 
EXPERIMENT – 9
OBJECTIVE - Write a C++ program to perform insertion at ending of linked list. 

Code –

#include <iostream>
using namespace std;
class node
{
public:
    int data;
    node *next;
    node(int val)
    {
        data = val;
        next = NULL;
    }
};
void insertAtTail(node *&head, int val)
{
    node *n = new node(val);
    if (head == NULL)
    {
        head = n;
        return;
    }
    node *temp = head;
    while (temp->next != NULL)
    {
        temp = temp->next;
    }
    temp->next = n;
}
void display(node *head)
{
    node *temp = head;
    while (temp != NULL)
    {
        cout << temp->data << "->";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
int main()
{
    node *head = NULL;
    int data, n, x;
    do
    {
        cout << "Enter 1 to Insert at End" << endl;
        cout << "Enter 2 to Display linked List" << endl;
        cout << "Enter 3 to EXIT." << endl;
        cin >> x;
        switch (x)
        {
        case 1:
            cout << "Enter No of values to be Inserted at Beginning" << endl;
            cin >> n;
            cout << "Enter the values to be inserted at the beginning" << endl;
            for (int i = 0; i < n; i++)
            {
                cin >> data;
                insertAtTail(head, data);
            }
            break;
        case 2:
            cout << "The Linked List is :- " << endl;
            display(head);
            break;
        case 3:
            break;
        default:
            cout << "Invalid Choice" << endl;
        }
    } while (x != 3);
    return 0;
}

 
Output –




 
EXPERIMENT – 10 
OBJECTIVE - Write a program to insert a new node in linked list after given node. 
Code –

#include <iostream>
using namespace std;
class node {
public:
    int data;
    node *next;
    node(int val) {
        data = val;
        next = NULL;
    }
};
void insert(node *&head, int val) {
    node *n = new node(val);
    if (head == NULL) {
        head = n;
        return;
    }
    node *temp = head;
    while (temp->next != NULL)
        temp = temp->next;
    temp->next = n;
}
void display(node *head) {
    node *temp = head;
    while (temp != NULL) {
        cout << temp->data << "->";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
void search_Insert(node *head, int key) {
    node *temp = head;
    while (temp != NULL) {
        if (temp->data == key) {
            break;
        }
        temp = temp->next;
    }
    if (temp->data == key) {
        int value;
        cout << "Location found" << endl
             << "Enter the new element to be inserted : ";
        cin >> value;
        node *new_node = new node(value);
        new_node->data = value;
        new_node->next = temp->next;
        temp->next = new_node;
    }
    else {
        cout << "Location not Found!!!!!!" << endl;
    }
}
int main() {
    int a, ele;
    node *head = NULL;
    insert(head, 21);
    insert(head, 37);
    insert(head, 42);
    insert(head, 69);
    insert(head, 23);
    insert(head, 88);
    cout << endl
         << "You have following the Linked List : " << endl;
    display(head);
    do {
        cout << "1. For search and Insert after the element" << endl
             << "2. For Display" << endl
             << "3. For EXIT." << endl;
        cout << "Enter your choice : ";
        cin >> a;
        switch (a) {
        case 1:
            cout << "Enter a element to be searched : ";
            cin >> ele;
            search_Insert(head, ele);
            break;
        case 2:
            display(head);
            break;
        case 3:
            break;
        default:
            cout << "Invalid Choice!!!!!!!!!!";
        }
    } while (a != 3);
    return 0;
}

Output –


 

 
EXPERIMENT – 11
Objective - Write a code to implement deletion from head in Linked List.

Code – 

#include <iostream>
using namespace std;
class node
{
public:
    int data;
    node *next;
    node(int val)
    {
        data = val;
        next = NULL;
    }
};
void insert(node *&head, int val)
{
    node *n = new node(val);
    if (head == NULL)
    {
        head = n;
        return;
    }
    node *temp = head;
    while (temp->next != NULL)
    {
        temp = temp->next;
    }
    temp->next = n;
}
void delete_head(node *&head)
{
    node *todelete = head;
    head = head->next;
    delete todelete;
}
void display(node *head)
{
    node *temp = head;
    while (temp != NULL)
    {
        cout << temp->data << "->";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
int main()
{
    node *head = NULL;
    int a, ele;
    insert(head, 19);
    insert(head, 12);
    insert(head, 63);
    insert(head, 69);
    insert(head, 88);
    insert(head, 29);
    cout << endl
         << "You have following the Linked List : " << endl;
    display(head);
    do
    {
        cout << endl
             << "1. For Delete head element." << endl
             << "2. For Display" << endl
             << "3. For Exit" << endl;
        cout << "Enter your choice : ";
        cin >> a;
        switch (a)
        {
        case 1:
            delete_head(head);
            break;
        case 2:
            display(head);
            break;
        case 3:
            break;
        default:
            cout << endl
                 << "Wrong Choice. Try again ";
        }
    } while (a != 3);
    return 0;
}

 
Output –



 
EXPERIMENT – 12
Objective - Write a code to implement deletion of given node in Linked List.

Code – 

#include <iostream>
using namespace std;
class node
{
public:
    int data;
    node *next;
    node(int val) {
        data = val;
        next = NULL;
    }
};
void insert(node *&head, int val) {
    node *n = new node(val);
    if (head == NULL)
    {
        head = n;
        return;
    }
    node *temp = head;
    while (temp->next != NULL)
    {
        temp = temp->next;
    }
    temp->next = n;
}
void deletion(node *&head, int val) {
    if (head == NULL) {
        return;
    }
    node *temp = head;
    while (temp->next->data != val) {
        temp = temp->next;
    }
    node *todelete = temp->next;
    temp->next = temp->next->next;
    delete todelete;
}
void display(node *head)
{
    node *temp = head;
    while (temp != NULL)
    {
        cout << temp->data << "->";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
int main()
{
    node *head = NULL;
    int a, ele;
    insert(head, 19);
    insert(head, 12);
    insert(head, 63);
    insert(head, 69);
    insert(head, 88);
    insert(head, 29);
    cout << endl << "You have following the Linked List : " << endl;
    display(head);
    do
    {
        cout << endl
             << "1. For Search and Delete " << endl
             << "2. For Display" << endl << "3. For Exit" << endl;
        cout << "Enter your choice : ";
        cin >> a;
        switch (a)
        {
        case 1:
            cout << endl << "Enter a element to be deleted : ";
            cin >> ele;
            deletion(head, ele);
            break;
        case 2:
            display(head);
            break;
        case 3:
            break;
        default:
            cout << endl << "Wrong Choice. Try again ";
        }
    } while (a != 3);
    return 0;
}
Output –

 
 
EXPERIMENT – 13
Objective - Write a code to implement deletion from end in Linked List.

Code – 

#include <iostream>
using namespace std;
class node
{
public:
    int data;
    node *next;
    node(int val) {
        data = val;
        next = NULL;
    }
};
void insert(node *&head, int val)
{
    node *n = new node(val);
    if (head == NULL)
    {
        head = n;
        return;
    }
    node *temp = head;
    while (temp->next != NULL)
        temp = temp->next;
    temp->next = n;
}
void deletion(node *&head)
{
    if (head == NULL)
    {
        return;
    }
    node *temp = head;
    while (temp->next->next != NULL)
        temp = temp->next;
    node *todelete = temp->next;
    temp->next = NULL;
    cout << "Deleted Node : " << todelete->data << endl;
    delete (todelete);
}
void display(node *head)
{
    node *temp = head;
    while (temp != NULL)
    {
        cout << temp->data << "->";
        temp = temp->next;
    }
    cout << "NULL" << endl;
}
int main()
{
    node *head = NULL;
    int a, ele;
    insert(head, 19);
    insert(head, 12);
    insert(head, 63);
    insert(head, 69);
    insert(head, 88);
    insert(head, 29);
    cout << endl << "You have following the Linked List : " << endl;
    display(head);
    do
    {
        cout << endl
             << "1. For Delete end Element " << endl
             << "2. For Display" << endl
             << "3. For Exit" << endl;
        cout << "Enter your choice : ";
        cin >> a;
        switch (a)
        {
        case 1:
            deletion(head);
            break;
        case 2:
            display(head);
            break;
        case 3:
            break;
        default:
            cout << endl << "Wrong Choice. Try again ";
        }
    } while (a != 3);
    return 0;
}
Output –

 
 
EXPERIMENT – 14
Objective - Write a code to implement stack using Linked List.

Code – 

#include <iostream>
using namespace std;
class Node {
public:
    int data;
    Node* link;
    Node(int n)
    {
        this->data = n;
        this->link = NULL;
    }
};
class Stack {
    Node* top;
public:
    Stack() { top = NULL; }
    void push(int data)
    {
        Node* temp = new Node(data);
        if (!temp) {
            cout << "\nStack Overflow";
            exit(1);
        }
        temp->data = data;
        temp->link = top;
        top = temp;
    }
    int peek()
    {
        if (top!=NULL)
            return top->data;
        else
            exit(1);
    }
    void pop()
    {
        Node* temp;
        if (top == NULL) {
            cout << "\nStack Underflow" << endl;
            exit(1);
        }
        else {
            temp = top;
            top = top->link;
            delete temp;
        }
    }
    void display()
    {
        Node* temp;
        if (top == NULL) {
            cout << "\nStack Underflow";
            exit(1);
        }
        else {
            temp = top;
            while (temp != NULL) {
                cout << temp->data;
                temp = temp->link;
                if (temp != NULL)
                    cout << " -> ";
            }
        }
    }
};
int main()
{
    Stack s;
    s.push(11);
    s.push(22);
    s.push(33);
    s.push(44);
    s.push(55);

    s.display();
    cout << "\nTop element is " << s.peek() << endl;
    s.push(66);
    s.display();
    cout << "\nTop element is " << s.peek() << endl;
    s.pop();
    s.pop();
    s.display();
    cout << "\nTop element is " << s.peek() << endl;

    return 0;
}

Output –




 
EXPERIMENT – 15
Objective - Write a code to implement QUEUE using Linked List.

Code – 

#include <iostream>
using namespace std;
struct QNode
{
    int data;
    QNode *next;
    QNode(int d)
    {
        data = d;
        next = NULL;
    }
};
struct Queue
{
    QNode *front, *rear;
    Queue() { front = rear = NULL; }
    void enQueue(int x)
    {
        QNode *temp = new QNode(x);
        if (rear == NULL)
        {
            front = rear = temp;
            return;
        }
        rear->next = temp;
        rear = temp;
    }
    void deQueue()
    {
        if (front == NULL)
            return;
        QNode *temp = front;
        front = front->next;
        if (front == NULL)
            rear = NULL;
        delete (temp);
    }
    void display()
    {
        QNode *temp;
        if (front == NULL)
        {
            cout << "\nQueue Underflow" << endl;
            exit(1);
        }
        else {
            temp = front;
            while (temp != NULL)
            {
                cout << temp->data;
                temp = temp->next;
                if (temp != NULL)
                    cout << " -> ";
            }
            cout << endl;
        }
    }
};
int main()
{
    Queue q;
    q.enQueue(10);
    q.enQueue(20);
    q.display();
    q.deQueue();

    cout << "Queue after one dequeue. " << endl;
    q.display();
    q.enQueue(30);
    q.enQueue(40);
    q.enQueue(50);

    cout << "Queue after three enqueue. " << endl;
    q.display();
    cout << "Queue Front : " << ((q.front != NULL) ? (q.front)->data : -1) << endl;
    cout << "Queue Rear : " << ((q.rear != NULL) ? (q.rear)->data : -1) << endl;

    q.deQueue();
    q.deQueue();
    cout << "Queue after two dequeue. " << endl;
    q.display();

    cout << "Queue Front : " << ((q.front != NULL) ? (q.front)->data : -1) << endl;
    cout << "Queue Rear : " << ((q.rear != NULL) ? (q.rear)->data : -1);
    return 0;
}

Output –

 


 
EXPERIMENT – 16
Objective - Write a code to implement insertion and deletion from starting in a doubly Linked List.

Code – 

#include <iostream>
using namespace std;
class node {
public:
    int data;
    node *next;
    node *prev;
    node(int val)
    {
        data = val;
        next = NULL;
        prev = NULL;
    }
};
class DoubleLinkedList {
public:
    node *head;
    node *tail;
    DoubleLinkedList() {
        head = NULL;
        tail = NULL;
    }
    void InsertAtFront(int value) {
        node *n = new node(value);
        if (head == NULL) {
            head = n;
            tail = n;
        }
        else {
            head->prev = n;
            n->next = head;
            head = n;
        }
    }
    void DeleteAtFront() {
        node *t = head;
        node *todelete = t;
        head = t->next;
        head->prev = NULL;
        cout << "Deleted Node is " << todelete->data << endl;
        delete (todelete);
    }
    void display() {
        node *temp = head;
        cout << "NULL<-";
        while (temp != NULL) {
            cout << temp->data << "->";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }
};
int main() {
    DoubleLinkedList l;
    int data, n, x;
    do {
        cout << "Enter 1 to insert at beginning." << endl
             << "Enter 2 to deleting from front." << endl
             << "Enter 3 to Display." << endl << "Enter 4 to exit." << endl;
        cin >> x;
        switch (x)
        {
        case 1:
            cout << "Enter the number of values to be inserted at beginning." << endl;
            cin >> n;
            cout << "Enter the values to be inserted : ";
            for (int i = 0; i < n; i++) {
                cin >> data;
                l.InsertAtFront(data);
            }
            break;
        case 2:
            l.DeleteAtFront();
            break;
        case 3:
            cout << "The linked List is : " << endl;
            l.display();
            break;
        case 4:
            break;
        default:
            cout << "Invalid Choice!!!!!!!!!!!" << endl;
        }
    } while (x != 4);
    return 0;
}
Output –


 
EXPERIMENT – 17
Objective - Write a code to implement insertion & deletion from a given node using doubly Linked List.

Code – 

#include <iostream>
using namespace std;
class node {
public:
    int data;
    node *next;
    node *prev;
    node(int val) {
        data = val;
        next = NULL;
        prev = NULL;
    }
};
class doublellist {
public:
    node *head;
    node *tail;
    doublellist() {
        head = NULL;
        tail = NULL;
    }
    void InsertAtFront(int value) {
        node *n = new node(value);
        if (head == NULL) {
            head = n;
            tail = n;
        }
        else {
            head->prev = n;
            n->next = head;
            head = n;
        }
    }
    void InsertAtMid(int key) {
        node *curr = head;
        while (curr->data != key) {
            curr = curr->next;
        }
        if (curr->data == key) {
            int value;
            cout << "Location found" << endl;
            cout << "Enter the new element to be Inserted : ";
            cin >> value;
            node *new_node = new node(value);
            curr->next->prev = new_node;
            new_node->next = curr->next;
            curr->next = new_node;
            new_node->prev = curr;
        }
        else {
            cout << "Location not found!!!!!!" << endl;
        }
    }
    void DeleteAtMid(int value) {
        node *curr = head;
        node *pre = head;
        while (curr->data != value) {
            pre = curr;
            curr = curr->next;
        }
        if (curr->data == value)
        {
            cout << "Location found" << endl;
            curr->next->prev = pre->next;
            pre->next = curr->next;
            cout << "Deleted Node : " << curr->data << endl;
            delete (curr);
            return;
        }
    }
    void display()
    {
        node *temp = head;
        cout << "NULL<-";
        while (temp != NULL)
        {
            cout << temp->data << "<->";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }
};
int main()
{
    doublellist l;
    l.InsertAtFront(10);
    l.InsertAtFront(20);
    l.InsertAtFront(30);
    l.InsertAtFront(40);
    l.InsertAtFront(50);
    cout << "You have following Double Linked List : " << endl;
    l.display();
    int data, x;
    do
    {
        cout << "Enter 1 to insert at any node." << endl
             << "Enter 2 to deleting from any node." << endl
             << "Enter 3 to Display." << endl
             << "Enter 4 to exit." << endl;
        cin >> x;
        switch (x)
        {
        case 1:
            cout << "Enter the node after which new node is inserted : ";
            cin >> data;
            l.InsertAtMid(data);
            break;
        case 2:
            cout << "Enter the node which is deleted : ";
            cin >> data;
            l.DeleteAtMid(data);
            break;
        case 3:
            cout << "The linked List is : " << endl;
            l.display();
            break;
        case 4:
            break;
        default:
            cout << "Invalid Choice!!!!!!!!!!!" << endl;
        }
    } while (x != 4);
    return 0;
}
 

Output –


 
EXPERIMENT – 18
Objective - Write a code to implement insertion & deletion from end of a double Linked List.

Code – 

#include <iostream>
using namespace std;
class node
{
public:
    int data;
    node *next;
    node *prev;
    node(int val)
    {
        data = val;
        next = NULL;
        prev = NULL;
    }
};
class doublellist
{
public:
    node *head;
    node *tail;
    doublellist()
    {
        head = NULL;
        tail = NULL;
    }
    void InsertAtFront(int value)
    {
        node *n = new node(value);
        if (head == NULL)
        {
            head = n;
            tail = n;
        }
        else
        {
            head->prev = n;
            n->next = head;
            head = n;
        }
    }
    void InsertAtEnd(int value)
    {

        node *curr = head;
        while (curr->next != NULL)
        {
            curr = curr->next;
        }
        node *new_node = new node(value);
        curr->next = new_node;
        new_node->prev = curr;
    }
    void DeleteAtEnd()
    {
        node *curr = head;
        node *pre = head;
        while (curr->next != NULL)
        {
            pre = curr;
            curr = curr->next;
        }
        if (curr->next == NULL)
        {
            cout << "Location found" << endl;
            pre->next = NULL;
            curr->prev = NULL;
            cout << "Deleted Node : " << curr->data << endl;
            delete (curr);
            return;
        }
    }
    void display()
    {
        node *temp = head;
        cout << "NULL<-";
        while (temp != NULL)
        {
            cout << temp->data << "<->";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    }
};

int main()
{
    doublellist l;
    l.InsertAtFront(10);
    l.InsertAtFront(20);
    l.InsertAtFront(30);
    l.InsertAtFront(40);
    l.InsertAtFront(50);
    cout << "You have following Double Linked List : " << endl;
    l.display();
    int data, n, x;
    do
    {
        cout << "Enter 1 to insert at Ending." << endl
             << "Enter 2 to deleting from End." << endl
             << "Enter 3 to Display." << endl
             << "Enter 4 to exit." << endl;
        cin >> x;
        switch (x)
        {
        case 1:
            cout << "Enter the number of values to be inserted at ending." << endl;
            cin >> n;
            cout << "Enter the values to be inserted : ";
            for (int i = 0; i < n; i++)
            {
                cin >> data;
                l.InsertAtEnd(data);
            }
            break;
        case 2:
            l.DeleteAtEnd();
            break;
        case 3:
            cout << "The linked List is : " << endl;
            l.display();
            break;
        case 4:
            break;
        default:
            cout << "Invalid Choice!!!!!!!!!!!" << endl;
        }
    } while (x != 4);
    return 0;
}

 
Output –

 
EXPERIMENT – 19
Objective - Write a code to implement insertion & deletion from front using circular Linked List.
Code – 
#include <iostream>
using namespace std;
class node {
public:
    int data;
    node *next;
};
class circularLinkedList {
private:
    node *head;
    node *tail;
public:
    circularLinkedList() {
        head = NULL;
        tail = NULL;
    }
    void InsertAtFront(int data) {
        node *newnode = new node();
        newnode->data = data;
        newnode->next = NULL;
        if (head == NULL) {
            head = newnode;
            tail = newnode;
            newnode->next = head;
        }
        else {
            node *temp = head;
            newnode->next = temp;
            while (temp->next != head)
                temp = temp->next;
            temp->next = newnode;
            head = newnode;
        }
    }
    void DeleteFromFront() {
        node *temp = head;
        node *todelete = head;
        while (temp->next != head)
            temp = temp->next;
        temp->next = head->next;
        head->next = NULL;
        head = temp->next;
        cout << "Deleted Node : " << todelete->data << endl;
        delete (todelete);
    }
    void display() {
        node *temp = head;
        if (head == NULL) {
            cout << "List is empty.\n";
            return;
        }
        cout << "List elements: ";
        do {
            cout << temp->data << "->";
            temp = temp->next;
        } while (temp != head);
        cout << endl;
    }
};
int main() {
    circularLinkedList cll;
    int data, n, x;
    do {
        cout << "Enter 1 to insert at beginning." << endl
             << "Enter 2 to deleting from front." << endl
             << "Enter 3 to Display." << endl << "Enter 4 to exit." << endl;           
        cin >> x;
        switch (x) {
        case 1:
            cout << "Enter the number of values to be inserted at beginning." << endl;
            cin >> n;
            cout << "Enter the values to be inserted : ";
            for (int i = 0; i < n; i++) {
                cin >> data;
                cll.InsertAtFront(data);
            }
            break;
        case 2:
            cll.DeleteFromFront();
            break;
        case 3:
            cll.display();
            break;
        case 4: break;
        default: cout << "Invalid Choice!!!!!!!!!!!" << endl;
        }
    } while (x != 4);
    return 0;
}
Output –

 
 
EXPERIMENT – 20
Objective - Write a code to implement insertion & deletion from end using circular Linked List.
Code – 
#include <iostream>
using namespace std;
class node {
public:
    int data;
    node *next;
};
class circularLinkedList {
private:
    node *head;
    node *tail;
public:
    circularLinkedList() {
        head = NULL;
        tail = NULL;
    }
    void InsertAtEnd(int data) {
        node *newnode = new node();
        newnode->data = data;
        newnode->next = NULL;
        if (head == NULL) {
            head = newnode;
            tail = newnode;
            newnode->next = head;
            cout << newnode->data << " Inserted." << endl;
        }
        else {
            newnode->next = head;
            tail->next = newnode;
            tail = newnode;
        }
    }
    void DeletefromEnd() {
        node *temp = head;
        while (temp->next != tail)
            temp = temp->next;
        node *todelete = tail;
        temp->next = head;
        tail->next = NULL;
        tail = temp;
        cout << "Deleted Node : " << todelete->data << endl;
        delete (todelete);
    }
    void display() {
        node *temp = head;
        if (head == NULL) {
            cout << "List is empty.\n";
            return;
        }
        cout << "List elements: ";
        do {
            cout << temp->data << "->";
            temp = temp->next;
        } while (temp != head);
        cout << endl;
    }
};
int main() {
    circularLinkedList cll;
    int data, n, x;
    do {
        cout << "Enter 1 to insert at Ending." << endl
             << "Enter 2 to deleting from End." << endl
             << "Enter 3 to Display." << endl
             << "Enter 4 to exit." << endl;
        cin >> x;
        switch (x) {
        case 1:
            cout << "Enter the number of values to be inserted at Ending." << endl;
            cin >> n;
            cout << "Enter the values to be inserted : ";
            for (int i = 0; i < n; i++) {
                cin >> data;
                cll.InsertAtEnd(data);
            }
            break;
        case 2:
            cll.DeletefromEnd();
            break;
        case 3:
            cll.display();
            break;
        case 4: break;
        default:
            cout << "Invalid Choice!!!!!!!!!!!" << endl;
        }
    } while (x != 4);
    return 0;
}

Output –

 
 
EXPERIMENT – 21
Objective - Write a code to implement insertion & deletion from middle using circular Linked List.

Code – 

#include <iostream>
using namespace std;
class node {
public:
    int data;
    node *next;
};
class circularLinkedList {
private:
    node *head;
    node *tail;
public:
    circularLinkedList() {
        head = NULL;
        tail = NULL;
    }
    void InsertAtFront(int data) {
        node *newnode = new node();
        newnode->data = data;
        newnode->next = NULL;
        if (head == NULL) {
            head = newnode;
            tail = newnode;
            newnode->next = head;
        }
        else {
            node *temp = head;
            newnode->next = temp;
            while (temp->next != head) {
                temp = temp->next;
            }
            temp->next = newnode;
            head = newnode;
        }
    }
    void InsertAtMid(int key) {
        node *temp = head;
        while (temp->next != head) {
            if (temp->data == key) {
                break;
            }
            temp = temp->next;
        }
        if (temp->data == key) {
            int value;
            cout << "Location Found " << endl << "Enter the new value : ";
            cin >> value;
            node *newnode = new node();
            newnode->data = value;
            newnode->next = NULL;
            newnode->next = temp->next;
            temp->next = newnode;
        }
        else {
            cout << "Location Not found." << endl;
        }
    }
    void deleteAtMid(int key) {
        node *temp = head;
        while (temp->next->data != key) {
            temp = temp->next;
        }
        if (temp->next->data == key) {
            node *todelete = temp->next;
            temp->next = temp->next->next;
            cout << "Deleted Node : " << todelete->data << endl;
            delete (todelete);
        }
        else {
            cout << "Node not found." << endl;
        }
    }
    void display() {
        node *temp = head;
        if (head == NULL) {
            cout << "List is empty.\n";
            return;
        }
        cout << "List elements: ";
        do {
            cout << temp->data << "->";
            temp = temp->next;
        } while (temp != head);
        cout << endl;
    }
};
int main() {
    circularLinkedList cll;
    cll.InsertAtFront(40);
    cll.InsertAtFront(30);
    cll.InsertAtFront(20);
    cll.InsertAtFront(10);
    cout << "You have the following Circular Linked List. " << endl;
    cll.display();
    int data, n, x;
    do {
        cout << "Enter 1 to insert at a given Node." << endl
             << "Enter 2 to delete any node." << endl
             << "Enter 3 to Display." << endl
             << "Enter 4 to exit." << endl;
        cin >> x;
        switch (x) {
        case 1:
            cout << "Enter the node after which you want to insert : ";
            cin >> data;
            cll.InsertAtMid(data);
            break;
        case 2:
            cout << "Enter the Node you want to Delete : ";
            cin >> data;
            cll.deleteAtMid(data);
            break;
        case 3:
            cll.display();
            break;
        case 4:
            break;
        default:
            cout << "Invalid Choice!!!!!!!!!!!" << endl;
        }
    } while (x != 4);
    return 0;
}

 
Output –

 






















EXPERIMENT – 22
OBJECTIVE Write a program for in order traversing of Binary Search Tree.
Code –

#include <bits/stdc++.h>
using namespace std;

struct Node
{
    int data;
    Node *left;
    Node *right;
};
Node *newNode(int value)
{
    Node *node = new Node;
    node->data = value;
    node->left = node->right = NULL;
    return node;
}
void inOrder(Node *root)
{
    if (root == NULL)
        return;
    inOrder(root->left);
    cout << root->data << " ";
    inOrder(root->right);
}

int main()
{
    Node *root = newNode(50);
    root->left = newNode(30);
    root->right = newNode(70);
    root->left->left = newNode(20);
    root->left->right = newNode(40);
    root->right->left = newNode(60);
    root->right->right = newNode(80);

    cout << "In order traversal of the binary search tree is: \n";
    inOrder(root);
    cout << "\n";

    return 0;
}



Output –





 



























EXPERIMENT – 23
OBJECTIVE Write a Program for preorder traversing of Binary Search Tree. 
Code –

#include <bits/stdc++.h>
using namespace std;

struct Node
{
    int data;
    Node *left;
    Node *right;
};

Node *newNode(int value)
{
    Node *node = new Node;
    node->data = value;
    node->left = node->right = NULL;
    return node;
}

void preOrder(Node *root)
{
    if (root == NULL)
        return;
    cout << root->data << " ";
    preOrder(root->left);
    preOrder(root->right);
}
int main()
{
    Node *root = newNode(50);
    root->left = newNode(30);
    root->right = newNode(70);
    root->left->left = newNode(20);
    root->left->right = newNode(40);
    root->right->left = newNode(60);
    root->right->right = newNode(80);

    cout << "Preorder traversal of the binary search tree is: \n";
    preOrder(root);
    cout << "\n";

    return 0;
}
 
Output –




 
EXPERIMENT – 24
Objective - Write a Program for post order traversing of Binary Search Tree. 


Code – 

#include <bits/stdc++.h>
using namespace std;

struct Node
{
    int data;
    Node *left;
    Node *right;
};

Node *newNode(int value)
{
    Node *node = new Node;
    node->data = value;
    node->left = node->right = NULL;
    return node;
}

void printPostorder(Node *node)
{
    if (node == NULL)
        return;
    printPostorder(node->left);
    printPostorder(node->right);
    cout << node->data << " ";
}

int main()
{
    Node *root = newNode(50);
    root->left = newNode(30);
    root->right = newNode(70);
    root->left->left = newNode(20);
    root->left->right = newNode(40);
    root->right->left = newNode(60);
    root->right->right = newNode(80);

    cout << "Postorder traversal of the binary search tree is: \n";
    printPostorder(root);
    cout << "\n";

    return 0;
}
Output –

 

 
EXPERIMENT – 25
Objective - Write a program to implement selection sort on a linear array. 


Code – 

#include <bits/stdc++.h>
using namespace std;

void swap(int *xp, int *yp)
{
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

void selectionSort(int arr[], int n)
{
    int i, j, min_idx;
    for (i = 0; i < n - 1; i++)
    {
        min_idx = i;
        for (j = i + 1; j < n; j++)
            if (arr[j] < arr[min_idx])
                min_idx = j;
        swap(&arr[min_idx], &arr[i]);
    }
}

int main()
{

    int n;
    cout << "Enter the size of array: ";
    cin >> n;
    int arr[n];
    cout << "Enter the elements of array: ";
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    cout << "Unsorted Array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";

    cout << endl;
    selectionSort(arr, n);
    cout << "Sorted array using Selection Sort : \n";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << "\n";
    return 0;
}

Output –

 


 
EXPERIMENT – 26 
OBJECTIVE - Write a program to implement bubble sort on a linear array. 
 
Code –

#include <bits/stdc++.h>
using namespace std;

void swap(int *xp, int *yp)
{
  int temp = *xp;
  *xp = *yp;
  *yp = temp;
}

void bubbleSort(int arr[], int n)
{
  int i, j;
  for (i = 0; i < n - 1; i++)
    for (j = 0; j < n - i - 1; j++)
      if (arr[j] > arr[j + 1])
        swap(&arr[j], &arr[j + 1]);
}

int main()
{
  int n;
  cout << "Enter the size of array: ";
  cin >> n;
  int arr[n];
  cout << "Enter the elements of array: ";
  for (int i = 0; i < n; i++)
    cin >> arr[i];
    
  cout << "Unsorted Array: ";
  for (int i = 0; i < n; i++)
    cout << arr[i] << " ";

  cout << endl;

  bubbleSort(arr, n);
  cout << "Sorted array using Bubble Sort: \n";
  for (int i = 0; i < n; i++)
    cout << arr[i] << " ";
  cout << "\n";
  return 0;
}


Output –

 

 
EXPERIMENT – 27
Objective - Write a program to implement insertion sort on a linear array. 

Code – 

#include <iostream>
using namespace std;

int main()
{
    int n;
    cout << "Enter the size of the array: ";
    cin >> n;

    int arr[n];
    cout << "Enter the elements of the array: ";
    for (int i = 0; i < n; i++)
    {
        cin >> arr[i];
    }

    cout << "Unsorted Array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    for (int i = 1; i < n; i++)
    {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key)
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }

    cout << "Sorted array using Insertion Sort: ";
    for (int i = 0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}


 
Output –

 


 
EXPERIMENT – 28
Objective - Write a program to implement quick sort on a linear array. 

Code – 

#include <iostream>
using namespace std;

void swap(int *a, int *b)
{
  int temp = *a;
  *a = *b;
  *b = temp;
}

int partition(int arr[], int low, int high)
{
  int pivot = arr[high];
  int i = low - 1;
  for (int j = low; j < high; j++)
  {
    if (arr[j] <= pivot)
    {
      i++;
      swap(&arr[i], &arr[j]);
    }
  }
  swap(&arr[i + 1], &arr[high]);
  return i + 1;
}

void quickSort(int arr[], int low, int high)
{
  if (low < high)
  {
    int pi = partition(arr, low, high);
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
}

void printArray(int arr[], int n)
{
  for (int i = 0; i < n; i++)
  {
    cout << arr[i] << " ";
  }
  cout << endl;
}

int main()
{
  int n;
  cout << "Enter the size of the array: ";
  cin >> n;
  int arr[n];
  cout << "Enter the elements of the array: ";
  for (int i = 0; i < n; i++)
  {
    cin >> arr[i];
  }
  cout << "The original array is: ";
  printArray(arr, n);
  quickSort(arr, 0, n - 1);
  cout << "The sorted array using Quick Sort: ";
  printArray(arr, n);
  return 0;
}

Output –

 










EXPERIMENT – 29
Objective - Write a program to implement merge sort on a linear array. 



Code – 

#include <iostream>
using namespace std;

void merge(int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2)
    {
        if (L[i] <= R[j])
        {
            arr[k] = L[i];
            i++;
        }
        else
        {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1)
    {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2)
    {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r)
{
    if (l < r)
    {
        int m = l + (r - l) / 2;

        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}

int main()
{
    int n;
    cout << "Enter the size of the array: ";
    cin >> n;

    int arr[n];
    cout << "Enter the elements of the array: " << endl;
    for (int i = 0; i < n; i++)
    {
        cin >> arr[i];
    }
    cout << "Unsorted Array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";

    cout << endl;

    mergeSort(arr, 0, n - 1);

    cout << "Sorted array using Merge Sort: ";
    for (int i = 0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}


Output –



 


























EXPERIMENT – 30
Objective - Write a program to implement heap sort on a linear array.


Code – 

#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i)
{
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;

    if (l < n && arr[l] > arr[largest])
        largest = l;

    if (r < n && arr[r] > arr[largest])
        largest = r;

    if (largest != i)
    {
        swap(arr[i], arr[largest]);

        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n)
{
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    for (int i = n - 1; i >= 0; i--)
    {
        swap(arr[0], arr[i]);

        heapify(arr, i, 0);
    }
}

int main()
{
    int n;
    cout << "Enter the size of the array: ";
    cin >> n;

    int arr[n];
    cout << "Enter the elements of the array: ";
    for (int i = 0; i < n; i++)
    {
        cin >> arr[i];
    }

    cout << "Unsorted Array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";

    cout << endl;

    heapSort(arr, n);

    cout << "Sorted array using Heap Sort: ";
    for (int i = 0; i < n; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
 
Output –

 

